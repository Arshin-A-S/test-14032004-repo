# backend/components/fl_component.py
"""
Federated Learning component for real-time anomaly scoring.
This component loads the final model generated by the offline training pipeline
and uses it to score access requests based on their context.
"""

import json
import os
from datetime import datetime

# Define the path to the model relative to this file's location for robustness.
# This points to the model file generated by your training script.
BASE_DIR = os.path.dirname(os.path.abspath(__file__))
DEFAULT_MODEL_PATH = os.path.join(BASE_DIR, "..", "offline_sim", "fl_model_v2.json")

class FLComponent:
    def __init__(self, model_path: str = DEFAULT_MODEL_PATH):
        """
        Initializes the FLComponent by loading the trained v2 model.
        """
        self.model_path = model_path
        self.model = self._load_model()

    def _load_model(self):
        """Loads the v2 FL model from the specified path."""
        if not os.path.exists(self.model_path):
            # The model is a critical component; raise an error if it's missing.
            raise FileNotFoundError(
                f"FATAL: The trained FL model was not found at {self.model_path}. "
                f"Please run the 'federated_train_eval.py' script first."
            )
        
        with open(self.model_path, "r") as f:
            model = json.load(f)

        # Validate that this is a correctly trained v2 model
        if "schema" not in model or model["schema"] != "context-anomaly-model":
            raise ValueError(f"The model at {self.model_path} is not a valid v2 context anomaly model.")
        
        print("âœ… Federated Learning model loaded successfully.")
        return model

    def _hour_to_bucket(self, hour: int) -> str:
        """Converts the current hour (0-23) into a time bucket category."""
        # This logic matches your training scripts.
        if 0 <= hour < 6:   return "bucket_0_6"
        if 6 <= hour < 12:  return "bucket_6_12"
        if 12 <= hour < 18: return "bucket_12_18"
        return "bucket_18_24"

    def score_access(self, context: dict) -> float:
        """
        Scores an access request using the trained v2 federated model.
        Returns a risk score between 0.0 and 1.0.
        """
        # Extract context features, providing 'unknown' as a fallback
        loc = context.get("location", "unknown")
        dev = context.get("device_id") or context.get("device", "unknown")
        dept = context.get("department", "unknown")
        
        # Get the current time and convert to the correct time bucket
        current_hour = datetime.now().hour
        time_bucket = self._hour_to_bucket(current_hour)

        # --- Perform Inference using the loaded model ---
        weights = self.model["decision"]["weights"]
        learned = self.model["learned"]
        global_rate = learned["global_success_rate"]

        # Look up success rates for each feature, falling back to the global rate
        loc_rate = learned["location_success_rate"].get(loc, global_rate)
        dev_rate = learned["device_success_rate"].get(dev, global_rate)
        time_rate = learned["time_success_rate"].get(time_bucket, global_rate)
        dept_rate = learned["department_success_rate"].get(dept, global_rate)

        # Calculate risk for each feature (risk = 1 - success_rate)
        loc_risk = 1.0 - float(loc_rate)
        dev_risk = 1.0 - float(dev_rate)
        time_risk = 1.0 - float(time_rate)
        dept_risk = 1.0 - float(dept_rate)

        # Calculate the final weighted score, now including all four features
        score = (
            weights["location"] * loc_risk +
            weights["device"] * dev_risk +
            weights["time"] * time_risk +
            weights["department"] * dept_risk
        )
        
        # Clamp the final score to be between 0.0 and 1.0
        return max(0.0, min(1.0, float(score)))